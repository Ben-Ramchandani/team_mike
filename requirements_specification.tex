\documentclass[a4paper,10pt]{article}
%\documentclass[a4paper,10pt]{scrartcl}

\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{makeidx}
\usepackage[margin=1.2in]{geometry}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\title{}
\author{}
\date{}
\makeindex
\pdfinfo{%
  /Title    (Project Specifications)
  /Author   (Team Mike)
  /Creator  (Razvan)
  /Producer ()
  /Subject  (Requirements and Specifications)
  /Keywords ()
}

\begin{document}

\begin{titlepage}
	\centering
	
	{\scshape\Large Team Mike\par}
	\vspace{4cm}
	{\huge\bfseries Put your Phone to Work\par}
	\vspace{1.5cm}
	{\Large\
	Specifications and Requirements
	\par}
	\vspace{2cm}
	{\Large\itshape 
	      Ben Ramchadani\\
	      Dmitrij Szamozvancev\\
	      Razvan Kusztos\\
	      James Wood \\
	      Laura Nechita \\
	      Jack Needham
	      \par}
	\vfill

% Bottom of the page
	{\large \today\par}
\end{titlepage}
\maketitle
\tableofcontents
\newpage
\section{Introduction}

\subsection{Project Abstract}
When people browse social media sites on their phones for hours every day, most of the CPU power goes unused. The old desktop equivalent of this problem was the screensaver, which did little of value until it was co-opted for distributed computing projects such as SETI@home. The purpose of the project is to create a platform that can perform useful computation in the background of a large number of mobile phones, while owners are on social media – or even while they are asleep. It will run cross-platform. It should give the appropriate incentives to users since it will drain batteries and probably incur network charges. 

\subsection{Project Description}
The aim of the project is to produce a system to which people can send large parallelizable computations, and which sends this work to be done on idle mobile devices.
\subsection{Risk Analysis}
There are some issues that this project will have to deal with, such as
\begin{itemize}
 \item The difficulty of finding a computation activity that users will want to run, that can be distributed, results verified to be correct and that we can implement.
 \item The difficulty of managing the security of the phone while executing code from a remote source.
 \item Keeping full CPU power while the screen is off.
\end{itemize}


\subsection{Background and Prior Work}
There have been a few similar projects in the past, generally focussing on personal computers. A notable example is BOINC, which powers SETI@home, amongst other projects. Particularly, in its volunteer computing projects, it has to deal with the fact that volunteers (users, in our terminology) are unaccountable. It does this by two result validation strategies: syntax checking and replication checking. Syntax checking is used to check that the result of a job has the expected form, and uses a function specified by the project (computation, in our terminology) to do this. Replication checking sends each job to multiple volunteers, and accepts the results only if there is a strict majority result. This also allows for some project-specific function to decide whether results are equivalent.

BOINC explicitly requires its volunteers to trust the code being run on their computers. This has the consequence of making projects opt-in on the part of volunteers, which limits the amount of projects there can be. In contrast, we will aim to have a system which is secure for users, so that each user can be sent arbitrary jobs without intervention.

\subsection{Terminology}
For clarity, we introduce the following terms:


\begin{description}
      \item [The server] is a computer managing customer-requested computations. This management includes the splitting of computations into jobs, the dispatching of jobs to users, and the assembly of results.
      \item [A computation] is a collection of code and data. The aim of the system is to run each computation it receives, and return each result to the relevant customer.
      \item [A customer] is an entity that sends in a computation, and expects its result.
      \item [A device] is any device on which customer code is executed. Initially, this refers only to Android devices, though we should build the system in such a way that any mobile device operating system can be supported.
      \item [A job] is some part of a computation which is to be completed by a single device.
      \item [A user] is a person using a device to do jobs. In practice, this also refers to the application running on the device. We specifically avoid the word “client”, given that it could be interpreted as “customer”.
      \item [The system.] The combination of server and devices is referred to as the system.
\end{description}
From the customer’s point of view, we provide a service to have large computations done quickly. For users, we plan to offer rewards for doing work, the details of which will be explored later in the document.



\section{System Requirements}


\subsection{Functional Requirements}

\begin{itemize}
	\item The framework shall allow distributed computation in the background of the users’ mobile phones.
	\item Users shall be able to run the computation in the background, from WiFi or mobile network, while charging and off the battery.
	\item The framework should provide a facility for customers to submit their own computations.
	\item The user application shall provide incentives or rewards for the users.
\end{itemize} 

\subsection{Performance Requirements}

\begin{itemize}
	\item Response times vary on the type of job, but long running jobs shall be interrupted after a timeout period has ended.
	\item The application should not drain battery, so the intensity of computation must be limited when the device is not charging.
	\item The computation should not impact the performance of other active applications heavily.
	\item The computation should not cause any overheating or damage the hardware.
	\item Data-heavy computation should not be performed over the mobile network.
	\item The server should have enough memory available to keep the input data as well as all the partial results.
\end{itemize} 

\subsection{Security Requirements}

\begin{itemize}
	\item The server managing computations and jobs must be secure.
	\item Users should not be able to access the rewards without performing useful work.
	\item No malicious code should be sent to the users from the server, and no malicious data should be sent from the users to the server.
\end{itemize} 

\subsection{Reliability}

\begin{itemize}
	\item Framework shall ensure persistence of computation.
	\item Server shall perform basic verification of result data.
	\item Server should be able to handle large numbers of users, manage new and leaving users without interrupting any active computation.
	\item In case of server failure the users should not accept new jobs and should not send data to the server until it is recovered.
	\item Data should not be lost on server shutdown.
\end{itemize} 

\subsection{Availability}

\begin{itemize}
	\item Server should prioritise devices that are statistically more likely to be able to perform heavy computation, e.g. depending on time zones.

\end{itemize} 

\subsection{Maintainability}

\begin{itemize}
	\item The framework should be able to handle short downtime periods of the server, as well as the server changing location and address.

\end{itemize} 

\subsection{Portability}

\begin{itemize}
	\item The framework shall use standard networking protocols for data exchange.
	\item The data passed between the server and users shall have a standard format (e.g. JSON) to ensure compatibility with different platforms.
\end{itemize} 

\subsection{Acceptance Criteria}

\begin{itemize}
	\item Client application can stably run in the background without draining the battery or using too much mobile data.
	\item Computations can run in parallel on multiple devices and provide useful, correct results to the server.
	\item Server can effectively manage running activities and jobs, send new jobs to clients, collect results and control timeouts.
	\item Server can verify the results and forward them to the customer.
	\item Server is reliable, robust and secure.
	\item Customers can easily submit new activities that fit the required interface/protocol.
	\item The platform offers suitable incentives for users, and/or rewards for performing computation.
	\item Users cannot cheat the system and get rewards without doing work, and customers cannot submit their projects for free.
\end{itemize}

\subsection{Per component requirements}

\subsubsection{Server}

\paragraph{Must:}

\begin{itemize}
\item Store active computations.
\item Send jobs and data to devices on request.
\item Be able to time out jobs that are not completed.
\item Receive data for completed jobs.
\item Retire computations that are complete, and make their result available.
\item Handle multiple connected devices.
\end{itemize}

\paragraph{Should:}

\begin{itemize}
\item Store who completed each job.
\item Verify jobs are correct where possible, and be able to send repeats of each job otherwise.
\item Be able to load in new computations at run time.
\item Be able to shutdown and resume without loss of result data.
\item Be flexible in the types of computation available.
\end{itemize}

\paragraph{Could:}

\begin{itemize}
\item Send a list of available activities to the phone on request.
\item Allow a phone to request a job from a certain computation.
\item Be able to handle computations which involve large input files.
\item Provide an interface for the customer to submit and get back computations.
\end{itemize}

\subsubsection{The app background service}

\paragraph{Must:}

\begin{itemize}
\item Fetch jobs and data from job server.
\item Get settings from the interface app.
\item Run job in the background.
\item Return data to job server.
\item Queue requests and job submission if no connection is available.
\end{itemize}

\paragraph{Should:}

\begin{itemize}
\item Cache computation data and code to lower network traffic.
\item Be able to suspend or stop computation on request from interface.
\item Run the computation with minimal permissions.
\item Provide an interface for the computation to fetch data over HTTP.
\item Rrun computations only at times determined by the settings.
\begin{itemize}
\item On charge.
\item Above \% battery.
\item On WiFi.
\item Combination of above.
\end{itemize}
\item Only use mobile network if allowed by settings.
\item Run when the device starts.
\item Keep track of time spent computing.
\end{itemize}

\subsubsection{The user interface app}

\paragraph{Must:}

\begin{itemize}
\item Have the following settings, and be able to communicate them to the background service.
\begin{itemize}
\item Enable/disable service.
\end{itemize}
\item Have the service be able to access the settings when the app is not running.
\item Be able to start the service.
\end{itemize}

\paragraph{Should:}

\begin{itemize}
\item Have the following settings, and be able to communicate them to the background service.
\begin{itemize}
\item Enable/disable service.
\item Run only when charging.
\item Only use WiFi.
\end{itemize}
\item Display current jobs/computations to user.
\item Display the time spent on computations.
\end{itemize}

\paragraph{Could:}

\begin{itemize}
\item Allow user to specify which activities to run.
\item Integrate with Facebook to post stats about computations completed.
\end{itemize}

\subsection{Acceptance criteria}

%%%

\section{Specification}

\subsection{System description}

Our system will consist of a server, an app for the worker devices and (possibly) an interface for the customer. We are modelling it after the MapReduce programming framework.

\subsubsection{Server}
The server is the bridge between the customers request and the working devices. It will run in a JVM and consist of a series of modules that process the data and transfer information across the network.

\paragraph{Network Module:}

The server and working devices will communicate via JSON messages, aiming for platform independence. This module is responsible for mapping the IP addresses of the devices with their ID, and spawning threads to incoming handle requests. It will also ensure that the message passing is reliable and signal any repeated errors from the devices. The types of messages and their contents will be described in further sections.

\paragraph{JSON Parse Module:}

This module is responsible for translating the data from the internal Java representation to the platform independent JSON format. 

%\paragraph{Parallelization Module:}
%
%The client will send requests that involve big data. This module will split the data into independent jobs that are solvable at the device level. The hyper-parameters can be either fixed or vary as we are able to gain insights into the pool of available devices. We restrict the customer in the sense that we require his inputs to allow a simple parallelization routine, as it is in the case of MapReduce. 

\paragraph{Computation module:}

This module will manage active computations, fetching jobs and data, passing on results, keeping track of their progress and handling failure, as well as allowing new computations to be added to the system.
We will have templates for computations, like MapReduce, that the customer provides the input for. We provide routines to parallelize the computations into jobs that run on individual devices.
Once a computation is complete the result will be written to the database and the result becomes available for request.

\paragraph{Scheduler Module:}

The server will keep a queue of available jobs and a queue of available devices. The scheduler will link the job and device. It could take into account whether the job is fitted for the device (e.g. send less data to a device that is not on charge). It should also track whether the jobs are being finalized in the selected time. If not, the job is sent again. However, the first result to come is the one that will be taken into account. This part is also concerned with keeping internal state of the server consistent; make sure that jobs receive only one result etc.

Whenever a valid result is received, the job associated is marked as completed, and it is passed back to the computation. The job ID and the phone that completed it is recorded in the database.

\paragraph{Database Module:}

This module is concerned with keeping a structured record of all the data, as well as easy means from fetching data from the customers' source and sending it to the devices.
It will store a record of completed computations and their result, a list of job ids and the phone that completed them, and a log of diagnostic messages and errors.It will also store data for specific computations and manage a separate HTTP server that handles extra data for computations. In the scope of each Computation, jobs and data should have unique keys integer keys in order to simplify the storage mechanisms.
If data is too large to be served by the job server then it will be handed off to a separate HTTP server running on a different port.
The database will be available for querying from from the server interface to fetch computation results and logs.

\subsubsection{Worker Devices}
The app for the worker devices is split into two main functionalities: the Worker App and the Background Service. 

\paragraph{The Worker App}
is the application through which we ensure that the device's owner has the incentives to let the app run. This will consist of a system of leaderboards, achievements and rewards, stats of the  computation performed, news about the project they are contributing to, sharing etc.
\paragraph{The Background Service} 
is the program that connects to the main server. Whenever the device is available it will notify the server, sending meta-information (battery life, location, position, charging state) that will aid in tailoring the job to not interfere with the owners' experience. It will receive Jobs from the server and send back the result. If the computation fails the device will discard and resend the availability message.

\subsubsection{Customer Interface}
The customer needs to specify to the server a series of data that will specify the computation, such as the input, a map function etc. He/She will choose the function that will be applied to the data either from a set of predefined one, or build one himself based on our templates.

\subsection{Interface Specifications}


\subsubsection{Server to device API}

The device will send requests to which the server will respond.
There will be no ongoing connections, which should reduce load on the server, and minimal state about currently available users, which simplifies the server network component.

\lstinputlisting[language=Ruby]{server_api_json.txt}

\newpage
\subsubsection{Computation interface}

We will extend this interface to create computation templates that the customer provides input for.
\lstinputlisting[language=Java]{Computation.java}

\lstinputlisting[language=Java]{ComputationCode.java}

\lstinputlisting[language=Java]{Job.java}



\subsection{Constraints, assumptions and dependencies}
\paragraph{Constraints}
\begin{itemize}
	\item The jobs should have small to medium computation in order to make sure at least one job is solved when the device is charging. This is due to the fact that we have no control on the amount of time the user lets his device charge.

	\item The amount of data which is sent over the network. Since we are using WiFi, the data size shouldn't be large in order to prevent data loss.
\end{itemize} 

\paragraph{Assumptions}
\begin{itemize}
	\item We assume at least one job will be executed each time the device is charging. 
	\item The given computation can be split into independent jobs which can be given to the devices.
	\item The phones will not overload due to both the computation and the charging.
	\item The user does not use the phone while charging.
\end{itemize} 

\end{document}
